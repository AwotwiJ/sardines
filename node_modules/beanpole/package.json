{
  "name": "beanpole",
  "description": "Routing on Steroids",
  "version": "0.1.19",
  "author": {
    "name": "Craig Condon"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/crcn/beanpole.git"
  },
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "sk": "*",
    "vine": "*",
    "mime": "*",
    "gumbo": "*",
    "cashew": "*",
    "structr": "*",
    "coffee-script": "*",
    "crema": "*"
  },
  "devDependencies": {
    "ebnf-diagram": "*"
  },
  "main": "./lib/node/index.js",
  "readme": "## Beanpole - Routing framework      \n               \n\n### What are some features?\n\t\n- Syntactic sugar (see below).                                         \n- Works with many protocols: amqp, http, websockets, etc.                      \n- Hooking with other applications is a breeze with [daisy](https://github.com/spiceapps/daisy).   \n- Works well with coffeescript \n\n\n### Projects using Beanpole\n\n- [celeri](https://github.com/spiceapps/celeri) - CLI library\n- [bonsai](https://github.com/spiceapps/bonsai) - application server\n- [leche](https://github.com/spiceapps/leche) - Framework to build frontend / backend applications with the same code.\n- [daisy](https://github.com/spiceapps/daisy) - Expose beanpole to: http, websockets, amqp (rabbitmq), etc.    \n- [beandocs](https://github.com/spiceapps/beandocs) - Generate documentation from your beanpole route comments.\n- [beanprep](https://github.com/spiceapps/beanprep) - Scans beans in a given directory, and installs their dependencies. \n- [cupboard](https://github.com/spiceapps/beanprep) - Reverse package manager.       \n\n### Beanpole ports\n\n- [Actionscript](https://github.com/crcn/beanpole.as)  \n- [C++](https://github.com/crcn/beanpoll)     \n\n### Overview          \n\n\n![Alt ebnf diagram](http://i.imgur.com/v1wdO.png)\n                \n\nThe basic route consists of a few parts: the `type` of route, and the `channel`. Here are some examples:\n\n\trouter.on('pull hello/:name', ...);\n\t\nand\n\n\trouter.on('push hello/:name', ...);           \n\t\n\n#### Push Routes:  \n\n- Used to broadcast a message, or change (1 to many).\n- Doesn't expect a response.    \n- Multiple listeners per route.         \n\n#### Pull Routes:\n\n- Used to request data from a particular route (1 to 1).\n- Expects a response.\n- One listener per route. \n- examples:\n\t- request to http-exposed route       \n\t\n\t\n\t                                                   \nUsing both `push`, and `pull` allows you to **bind** to a particular route. For example:\n\n\n````javascript\n\t    \nvar _numUsers = 0; \n        \n\n//numUser getter / setter function\nfunction numUsers(value)\n{\n\tif(!arguments.length) return _numUsers;\n\t\n\t_numUsers = value;\n\t                     \n\trouter.push('users/online', value);\n}\n\n\n//the request handler. This could be called in-app. It's also just as easily exposable as an API to http, websockets, etc.\nrouter.on('pull users/online', function(request)\n{\n\trequest.end(numUsers());\n});                                                    \n          \n//pull num users initially, then listen for when num users changes.\nrouter.on('push -pull users/online', function(response)\n{         \n\t//handle change here..\n\tconsole.log(response); //0, 3, 10...\n});                                        \n                               \n           \n\n//triggers above listener\nnumUsers(3);\nnumUsers(10);\n\n````        \n\nOkay, so you might have noticed I added something funky here: `-pull` - that's a tag. Tags are structured like so:\n\n   \trouter.on('pull -tagName hello/:route', ...);\n\nor, you can add a value to it:\n\n\trouter.on('pull -method=GET hello/:route', ...);\n\t\nAs mentioned above, you can only have *one* listener per `pull` route. HOWEVER, you can have multiple listeners per `pull` route *if* you provide different tag values. For example:\n\n````javascript\n\nrouter.on({\n\n\t/**      \n\t * returns the given user\n\t */\n\t\n\t'pull -method=GET users/:userId': function(request)\n\t{                           \n\t\t//get the specific user  \n\t},\n\t\n\t/**   \n\t * updates a user   \n\t */\n\t\n\t'pull -method=UPDATE users/:userId': function(request)\n\t{\n\t\t//update user here\n\t},\n\t\n\t/** \n\t * deletes a user\n\t */\n\t\n\t'pull -method=DELETE users/:userId': function(request)\n\t{\n\t\t//delete user \n\t}                         \n\t\n}); \n````       \n\nThe above chunk of code is well suited for a REST-ful api without explicilty writing it *for* an http server. It can be used for any protocol. For example - say I wanted to *delete* a user using the code above:\n\n````javascript\n\nrouter.pull('users/' + someUserId, { tag: { method: 'DELETE'} }, function()\n{\n\t//delete user response\n});  \n\n````                      \n\nYou might have guessed - tags can be used to filter routes. Okay, onto something a little more advanced: **middleware**. Here's an example:\n\n````javascript\n\n\nrouter.on({\n\t\n\t/**\n\t */\n\t\n\t'pull authorize': function(request)\n\t{\n\t\tif(request.data.secret != 'superSecret')\n\t\t{\n\t\t\trequest.end('You shall not pass!');\n\t\t}                                      \n\t\telse\n\t\t{             \n\t\t\t\n\t\t\t//onto the next route\n\t\t\trequest.next();\n\t\t}\n\t},\n\t\n\t/**\n\t */\n\t\n\t'pull -method=GET authorize -> my/profile': function(request)\n\t{\n\t\trequest.end('Super secret stuff!');\n\t}                      \n\t\n}); \n\n\n````\n                                          \nThe token `->` denotes `my/profile` must go *through* the `authorize` route. Here are a few more use-cases: \n\n````javascript\n    \nrouter.on({\n\t\n\t/**                \n\t */\n\t\n\t'pull post/body': function(request)\n\t{\n\t\t//post http request body here. This is implemented in daisy\n\t},             \n\t\n\t/**\n\t */\n\t\n\t'pull session': function(request)\n\t{\n\t\t//initialize cookies for the user. Again, implemented in daisy\n\t},\n\t\n\t/**\n\t */\n\t\n\t'pull -method=POST post/body -> session -> upload/video': function()\n\t{\n\t\t//passed through 2 routes before getting here.\n\t},\n\t\n\t/**\n\t */\n\t\n\t'pull cache/:ttl': function(request)\n\t{                                           \n\t\t//used to check if the *next* route is cached. If it is, then return the value vs continuing \n\t},\n\t\n\t/**\n\t */\n\t\n\t'pull cache/10000 -> some/heavy/request': function(request)\n\t{\n\t\t//do some heavy stuff here, but go through the cache route so it's not called on each request\n\t}                                                                                                \n\t\n\t\n})\n\n````      \n\nMiddleware is especially useful for a REST-ful interface:\n\n````javascript\n\nrouter.on({\n\t\n\t/**  \n\t * returns the given user\n\t * @example /users/665468459\n\t */\n\t\n\t'pull users/:userId': function(request)\n\t{\n\t\tgetUser(request.data.postId, funciton(user)\n\t\t{\n\t\t\trequest.user = user; \n\t\t\t                                            \n\t\t\t//route being used as middleware?\n\t\t\tif(request.hasNext()) return request.next();     \n\t\t\t                  \n\t\t\t//return the user\n\t\t\trequest.end(user);\n\t\t})\n\t},\n\t\n\t/** \n\t * Returns a post made by a particular user\n\t * @example /users/665468459/posts/54353499534\n\t */\n\t\n\t'pull users/:userId -> users/:userId/posts/:postId': function(request)\n\t{\n\t\tgetPosts(request.user, request.data.postId, function(posts)\n\t\t{\n\t\t\trequest.end(posts);\n\t\t})\n\t}\n});\n       \n````      \n           \nMiddleware can also be specified without using the token: `->`.An example:\n\n\n````javascript\n    \nrouter.on({               \n\t\n\t/**\n\t */\n\t\n\t'pull my/*': function()\n\t{\n\t\t//authorize user\n\t},  \n\t\n\t/**\n\t */\n\t\n\t'pull my/profile': function()\n\t{                 \n\t\t//goes through authorization first \n\t}\n});\n\n````                                                                         \n                                                                                                \nProviding a wildcard `*` tells the router that **anything** after the route must go through it.     \n\n### Managing very long routes\n\nYou may run into a route which looks like this:\n\n```javascript\nrouter.on({\n\t'pull -public -method=POST remove/cache/subscribers -> profile/validate/SAVE_ARTICLE -> groups/:group/subscribers OR groups/:group/subscribers/add': function() {\n\t\n});\n```\n\nTo fix the ugliness, breakup the route and escape any linebreaks:\n\n```javascript\nrouter.on({\n\t'pull \\\n\t-public -method=POST \\\n\tremove/cache/subscribers -> \\\n\tprofile/validate/SAVE_ARTICLE -> \\\n\tgroups/:group/subscribers OR \\\n\tgroups/:group/subscribers/add': function() {\n\t\t\n\t}\n})\n```\n\n\n### Methods            \n\n#### router.on(type[,listener])\n\nListens to the given routes\n\n- `type` - string or object. String would contain the route. Object would contain multiple routes / listeners\n- `listener` - function listening to the route given.                                                                                  \n\n\n#### router.push(route[, data][, options])\n\n- `type` - the channel broadcast a message to.\n- `data` - the data to push to the given route\n- `options` - options for the given route\n\t- `meta` - tags to use to filter out listeners\n\t\n#### router.pull(route[, data][, options][, callback])\n\nsame as push, but expects a response\n\n#### router.channels()\n\nreturns all registered channels\n\n#### router.getRoute(route)\n                      \nreturns route expression\n\n#### request.write(chunk)\n             \nInitializes a streamed response. Great for sending files\n\n#### request.end([chunk]) \n                        \nEnds a response \n\n#### request.hasNext()\n                                                     \nReturns TRUE if there's a listener after the current one.\n\n#### request.next()\n\nMoves onto the next route.\n\n#### request.forward(channel, callback)\n\nForwards the current request to the given channel\n\n#### request.thru(channel[ ,options])\n       \nTreats the given channel as middleware   \n\n#### request.data\n\nData is added here  \n\n\n### One last goodie\n\nBeanpole works well with coffeescript:\n\n\n````coffeescript\n\nrouter.on                        \n                   \n\t#\n\t'pull -method=GET say/hello': ->\n\t\t\"hello world!\"           \n\n````\n\n\n\n\n\n\n\n\n                                                                                                              \n\n",
  "readmeFilename": "README.md",
  "_id": "beanpole@0.1.19",
  "_from": "beanpole@*"
}
